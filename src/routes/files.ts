import { Router, Request, Response } from 'express';
import fs from 'fs-extra';
import path from 'path';
import { upload } from '../middleware/upload';
import { authenticate } from '../middleware/auth';

const router = Router();
const MOUNT_PATH = process.env.RAILWAY_VOLUME_MOUNT_PATH || path.join(process.cwd(), 'uploads');
const METADATA_DIR = path.join(MOUNT_PATH, 'metadata');

// Ensure metadata directory exists
fs.ensureDirSync(METADATA_DIR);

// POST /api/v1/files
router.post('/', authenticate, upload.single('file'), async (req: Request, res: Response) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: 'No file uploaded' });
        }

        const { customer_id, source, metadata: metadataStr } = req.body;

        // Parse optional metadata JSON string
        let customMetadata = {};
        if (metadataStr) {
            try {
                customMetadata = JSON.parse(metadataStr);
            } catch (e) {
                return res.status(400).json({ error: 'Invalid metadata JSON format' });
            }
        }

        // Construct file ID from the filename generated by multer (which already has a UUID)
        // Multer filename format: file_{uuid}-{original_name}
        // We can extract the ID or just use the whole filename as a reference, 
        // but the PRD suggests returning a file_id. 
        // Let's parse the ID we put in the filename in the middleware.
        const filenameParts = req.file.filename.split('-');
        // The first part is file_{uuid}
        const fileId = filenameParts[0];

        const relativePath = path.relative(MOUNT_PATH, req.file.path);

        const fileMetadata = {
            id: fileId,
            customer_id: customer_id || null,
            source: source || null,
            filename: req.file.originalname,
            content_type: req.file.mimetype,
            size_bytes: req.file.size,
            storage_backend: 'railway_volume',
            storage_volume_mount_path: MOUNT_PATH,
            storage_relative_path: relativePath,
            status: 'stored',
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
            processing: {
                state: 'stored',
                processed_at: null,
                error_message: null
            },
            custom_metadata: customMetadata
        };

        // Save metadata to disk
        await fs.writeJson(path.join(METADATA_DIR, `${fileId}.json`), fileMetadata);

        res.status(201).json(fileMetadata);
    } catch (error) {
        console.error('Upload error:', error);
        // Cleanup file if metadata save fails? 
        // For now, let's just return 500.
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

// GET /api/v1/files/:id
router.get('/:id', authenticate, async (req: Request, res: Response) => {
    try {
        const fileId = req.params.id;
        const metadataPath = path.join(METADATA_DIR, `${fileId}.json`);

        if (!await fs.pathExists(metadataPath)) {
            return res.status(404).json({ error: 'File not found' });
        }

        const metadata = await fs.readJson(metadataPath);
        res.json(metadata);
    } catch (error) {
        console.error('Get file error:', error);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

// DELETE /api/v1/files/:id
router.delete('/:id', authenticate, async (req: Request, res: Response) => {
    try {
        const fileId = req.params.id;
        const metadataPath = path.join(METADATA_DIR, `${fileId}.json`);

        if (!await fs.pathExists(metadataPath)) {
            return res.status(404).json({ error: 'File not found' });
        }

        const metadata = await fs.readJson(metadataPath);

        // Delete actual file
        const filePath = path.join(MOUNT_PATH, metadata.storage_relative_path);
        if (await fs.pathExists(filePath)) {
            await fs.unlink(filePath);
        }

        // Delete metadata file (or soft delete as per PRD, but let's hard delete for simplicity/cleanup for now unless strictly required)
        // PRD says: "Either soft-deletes metadata (status = deleted), Or hard-deletes based on data retention policy."
        // Let's soft delete for safety.
        metadata.status = 'deleted';
        metadata.updated_at = new Date().toISOString();
        await fs.writeJson(metadataPath, metadata);

        // If we want to hard delete the metadata file itself to clean up:
        // await fs.unlink(metadataPath);
        // But keeping it allows checking status later. 
        // However, if we keep it, GET /:id should probably return 404 or the deleted status.
        // PRD says "Returns 404 Not Found if no such file record exists or has been hard-deleted."
        // So if we soft delete, we might still want to return it or 404. 
        // Let's stick to soft delete update for now, but maybe we should just remove it to be clean for this MVP.
        // Actually, let's hard delete the metadata file to keep it simple and consistent with "404 if not found".
        await fs.unlink(metadataPath);

        res.status(204).send();
    } catch (error) {
        console.error('Delete file error:', error);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

export default router;
